---
layout: post
title: 前端知识点锦集
categories: 前端技术
description: some word here
tags: 前端 面试
---
* content
{:toc}
<div class="postImg" style="background-image:url(https://likonion-1254082995.cos.ap-chengdu.myqcloud.com/media/wieurowe.jpg)"></div>
个人整理前端的一些知识点，以便查询学习。



## JavaScript相关

### 闭包

#### 在经典的for循环中使用闭包

```js
for (var i=1; i<=5; i++) {
    setTimeout( function timer() {
         console.log( i ); // 每隔1秒输出‘6’、共输出5次
    }, i*1000 );
} 
```

修改上面的代码，让循环输出的结果依次为1， 2， 3， 4， 5

```js
// 方法一:使用自执行函数提供闭包条件，传入i值并保存在闭包中。
for (var i=1; i<=5; i++) {
    (function(i) {
        setTimeout( function timer() {
            console.log(i);
        }, i*1000 );
    })(i)
}
// 方法二:在setTimeout的第一个参数处利用闭包
for (var i=1; i<=5; i++) {
    setTimeout( (function(i) {
        return function() {
            console.log(i);
        }
    })(i), i*1000 );
}
// 方法三: ES6 let
for (let i=1; i<=5; i++) {
    setTimeout( function timer() {
         console.log( i );
    }, i*1000 );
}
```

## this、apply、call、bind

### this 的指向

在 ES5 中，其实 this 的指向，始终坚持一个原理：**this 永远指向最后调用它的那个对象** 。

例 1：
```js
var name = "windowsName";
function a() {
    var name = "Cherry";
    console.log(this.name);          // windowsName
    console.log("inner:" + this);    // inner: Window
}
a();
console.log("outer:" + this)         // outer: Window
```

例 2：
```js
var name = "windowsName";
var a = {
    name: "Cherry",
    fn : function () {
        console.log(this.name);      // Cherry
    }
}
a.fn();
```

### 怎么改变 this 的指向

改变 this 的指向我总结有以下几种方法：

* **使用 ES6 的箭头函数**

    众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。**箭头函数的 this 始终指向函数定义时的 this，而非执行时**。箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。
    ```js
    var name = "windowsName";
    var a = {
        name : "Cherry",
        func1: function () {
            console.log(this.name)
        },
        func2: function () {
            setTimeout( () => {
                this.func1()
            },100);
        }

    };
    a.func2()     // Cherry
    ```

* **在函数内部使用 _this = this**

    如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。
* **使用 apply、call、bind**

    ```js
      var a = {
        name : "Cherry",

        func1: function () {
            console.log(this.name)
        },

        func2: function () {
            setTimeout(  function () {
                this.func1()
            }.apply(a),100);
            //   }.call(a),100);
            //   }.bind(a)(),100);
        }

    };

    a.func2()            // Cherry
    ```

## 面向对象

### 一、对象的定义

在ECMAScript-262中，对象被定义为**“无序属性的集合，其属性可以包含基本值，对象或者函数”**。
也就是说，在JavaScript中，对象无非就是由一些列无序的key-value对组成。其中value可以是基本值，对象或者函数。
```js
// 这里的person就是一个对象
var person = {
    name: 'Tom',
    age: 18,
    getName: function() {},
    parent: {}
}
// 通过new的方式创建一个对象
var obj = new Object();
// 通过对象字面量的形式创建一个简单的对象
var obj = {};
```

### 二、工厂模式

顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个。

```js
var createPerson = function(name, age) {

    // 声明一个中间对象，该对象就是工厂模式的模子
    var o = new Object();

    // 依次添加我们需要的属性与方法
    o.name = name;
    o.age = age;
    o.getName = function() {
        return this.name;
    }

    return o;
}

// 创建两个实例
var perTom = createPerson('TOM', 20);
var PerJake = createPerson('Jake', 22);
```


### 三、构造函数
