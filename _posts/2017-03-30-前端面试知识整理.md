---
layout: post
title: 前端面试知识整理
categories: 前端技术
description: some word here
tags: 面试
---
* content
{:toc}
<div class="postImg" style="background-image:url(http://ovl1kjv88.bkt.clouddn.com/media/72988c62208946849c950caca8b1033f_th.jpg)"></div>



## HTML， HTTP，web综合问题

### Q: 前端需要注意哪些SEO

* 合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可
* 语义化的`HTML`代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
* 重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
* 重要内容不要用`js`输出：爬虫不会执行js获取内容
* 少用`iframe`：搜索引擎不会抓取`iframe`中的内容
* 非装饰性图片必须加`alt`
* 提高网站速度：网站速度是搜索引擎排序的一个重要指标

### Q: HTTP的几种请求方法用途

* 1、`GET`方法
  * 发送一个请求来取得服务器上的某一资源

* 2、`POST`方法
  * 向`URL`指定的资源提交数据或附加新的数据

* 3、`PUT`方法
  * 跟`POST`方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而`POST`没有

* 4、`HEAD`方法
  * 只请求页面的首部

* 5、`DELETE`方法
  * 删除服务器上的某资源

* 6、`OPTIONS`方法
  * 它用于获取当前`URL`所支持的方法。如果请求成功，会有一个`Allow`的头包含类似`“GET,POST”`这样的信息

* 7、`TRACE`方法
  * `TRACE`方法被用于激发一个远程的，应用层的请求消息回路

* 8、`CONNECT`方法
  * 把请求连接转换到透明的`TCP/IP`通道

### Q: 从浏览器地址栏输入url到显示页面的步骤

* 浏览器根据请求的`URL`交给`DNS`域名解析，找到真实`IP`，向服务器发起请求；
* 服务器交给后台处理完成后返回数据，浏览器接收文件（`HTML、JS、CSS`、图象等）；
* 浏览器对加载到的资源（`HTML、JS、CSS`等）进行语法解析，建立相应的内部数据结构（如`HTML`的`DOM`）；
* 载入解析到的资源文件，渲染页面，完成。

### Q: 如何进行网站性能优化

* `content`方面
  1. 减少`HTTP`请求：合并文件、`CSS`精灵、`inline Image`
  2. 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名
  3. 减少`DOM`元素数量
* `Server`方面
  1. 使用`CDN`
  2. 配置`ETag`
  3. 对组件使用`Gzip`压缩
* `Cookie`方面
  1. 减小`cookie`大小

* `css`方面
    1. 将样式表放到页面顶部
    2. 不使用`CSS`表达式
    3. 使用`<link>`不使用`@import`

* `Javascript`方面
    1. 将脚本放到页面底部
    2. 将`javascript`和`css`从外部引入
    3. 压缩`javascript`和`css`
    4. 删除不需要的脚本
    5. 减少`DOM`访问
* 图片方面
    1. 优化图片：根据实际颜色需要选择色深、压缩
    2. 优化`css`精灵
    3. 不要在`HTML`中拉伸图片

### Q: `HTML5`的离线储存怎么使用，工作原理能不能解释一下？

* 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件

* 原理：`HTML5`的离线存储是基于一个新建的`.appcache`文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像`cookie`一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示

* 如何使用：
  * 页面头部像下面一样加入一个`manifest`的属性；
  * 在`cache.manifest`文件的编写离线存储的资源
  * 在离线状态时，操作`window.applicationCache`进行需求实现

```javascript
CACHE MANIFEST
#v0.11
CACHE:
js/app.js
css/style.css
NETWORK:
resourse/logo.png
FALLBACK:
/ /offline.html
```

### Q: 浏览器是怎么对`HTML5`的离线储存资源进行管理和加载的呢

* 在线的情况下，浏览器发现`html`头部有`manifest`属性，它会请求`manifest`文件，如果是第一次访问`app`，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过`app`并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的`manifest`文件与旧的`manifes`t文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。

* 离线的情况下，浏览器就直接使用离线存储的资源。

### Q: 请描述一下 `cookies`，`sessionStorage` 和 `localStorage` 的区别？

* `cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）
* cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递
* `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存
* 存储大小：
  * `cookie`数据大小不能超过4k
  * `sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到5M或更大
* 有效时间：
  * `localStorage` 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据
  * `sessionStorage`  数据在当前浏览器窗口关闭后自动删除
  * `cookie`  设置的`cookie`过期时间之前一直有效，即使窗口或浏览器关闭

### Q: XML和JSON的区别？

* 数据体积方面

  * `JSON`相对于`XML`来讲，数据的体积小，传递的速度更快些。
* 数据交互方面

  * `JSON`与`JavaScript`的交互更加方便，更容易解析处理，更好的数据交互
* 数据描述方面

  * `JSON`对数据的描述性比`XML`较差
* 传输速度方面

  * `JSON`的速度要远远快于`XML`

### Q: 谈谈你对webpack的看法

`WebPack` 是一个模块打包工具，你可以使用`WebPack`管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包`Web`开发中所用到的`HTML`、`Javascript`、`CSS`以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，`webpack`有对应的模块加载器。`webpack`模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源

### Q: 常见web安全及防护原理

* `SQL`注入原理

  * 就是通过把`SQL`命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的`SQL`命令
* 总的来说有以下几点

  * 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等
  * 永远不要使用动态拼装`SQL`，可以使用参数化的`SQL`或者直接使用存储过程进行数据查询存取
  * 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
  * 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息
* `XSS`原理及防范

  * `Xss(cross-site scripting)`攻击指的是攻击者往Web页面里插入恶意html标签或者`javascript`代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点
* `XSS`防范方法

  * 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击
* XSS与CSRF有什么区别吗？

  * XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤

  * 登录受信任网站A，并在本地生成Cookie

  * 在不登出A的情况下，访问危险网站B

* CSRF的防御

  * 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数
  * 通过验证码的方法

### Q：标准盒子模型与IE怪异盒子模型

这个问题主要会出现在笔试题上面，比如：

```html
<div style="width:100px;height="100px;border:10px;padding:10px;"></div>
```

这个盒子在w3c标准盒子模型和IE的怪异盒子模型下面它的宽度分别是多少？

```html
标准盒子模型：总宽度=content100px+border 10px*2+padding 10px*2 //140px
怪异盒子模型: 总宽度=content60px+ border 10px*2+padding 10px*2 //100px
```

ps：

```bash
box-sizing： content-box || border-box；//css3 box-sizing设置为border-box将使用怪异盒子模型
当怪异盒子的宽度小于border+padding的宽度的时候，content width将变为0，盒子的宽度会被border和padding的总宽度撑开
```

### Q：HTTP状态码及其含义

* 1XX：信息状态码
  * 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
* 2XX：成功状态码
  * 200 OK 正常返回信息
  * 201 Created 请求成功并且服务器创建了新的资源
  * 202 Accepted 服务器已接受请求，但尚未处理
  * 206 & Partial Content: 对资源某一部分进行请求(比如对于只加载了一般的图片剩余部分的请求)
* 3XX：重定向
  * 301 Moved Permanently 请求的网页已永久移动到新位置。
  * 302 Found 临时性重定向。
  * 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。
  * 304 Not Modified 自从上次请求后，请求的网页未修改过。
* 4XX：客户端错误
  * 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
  * 401 Unauthorized 请求未授权。
  * 403 Forbidden 禁止访问。
  * 404 Not Found 找不到如何与 URI 相匹配的资源。
* 5XX: 服务器错误
  * 500 Internal Server Error 最常见的服务器端错误。
  * 502 & Bad Gateway: 错误的网关
  * 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）
  * 504 & Gateway timeout: 网关超时

### Q：Ajax的状态值

* 0: (未初始化)还没有调用send()方法。
* 1: (载入)已经调用send()方法，正在派发请求。
* 2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。
* 3: (交互)正在解析响应内容。
* 4: (完成)响应内容已经解析完成，用户可以调用。

### Q：语义化的理解

* 用正确的标签做正确的事情！
* html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；
* 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。
* 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。
* 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解

### Q: 介绍一下你对浏览器内核的理解？

* 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎

* 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核

* JS引擎则：解析和执行javascript来实现网页的动态效果

* 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎

### Q: html5有哪些新特性、移除了那些元素？

* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加

  * 绘画 canvas
  * 用于媒介回放的 video 和 audio 元素
  * 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失
  * sessionStorage 的数据在浏览器关闭后自动删除
  * 语意化更好的内容元素，比如article、footer、header、nav、section
  * 表单控件，calendar、date、time、email、url、search
  * 新的技术webworker, websocket, Geolocation
* 移除的元素：

  * 纯表现的元素：basefont，big，center，font, s，strike，tt，u`
  * 对可用性产生负面影响的元素：frame，frameset，noframes
* 支持HTML5新标签：

  * IE8/IE7/IE6支持通过document.createElement方法产生的标签
  * 可以利用这一特性让这些浏览器支持HTML5新标签
  * 浏览器支持新标签后，还需要添加标签默认的样式
* 当然也可以直接使用成熟的框架、比如html5shim

### Q: VUE相关知识

* `vue`的生命周期

  * `beforeCreate`: 组件实例刚刚被创建,组件属性计算之前,如data属性
  * `created`: 组件实例创建完成,属性已绑定,但是DOM还未完成,`$el`属性还不存在
  * `beforeMount`:模板编译/挂载之前
  * `mounted`: 模板编译/挂载之后
  * `beforeUpdate`: 组件更新之前
  * `updated`: 组件更新之后
  * `activated`: for keep-alive,组件被激活时调用
  * `deactivated`: for keep-alive,组件被移除时调用
  * `beforeDestroy`: 组件销毁前被调用
  * `destoryed`: 组件销毁后调用



## CSS部分

### Q：CSS的优先级

权重优先级：

* !important>style(1000)>id(100)>class(10)
* !important是优先级最高的不管权重多少，始终采取important。
* 如果两个选择器作用在同一元素上，计算权重值，相加。权重高者属性生效。（笔试题就出现过层叠的class id选择器，作用在同一个标签上，然后问最后哪个css属性生效）

> [你应该知道的一些事情——CSS权重](https://link.juejin.im/?target=https%3A%2F%2Fwww.w3cplus.com%2Fcss%2Fcss-specificity-things-you-should-know.html)

### Q：垂直居中有哪些方法？

* 单行文本的话可以使用height和line-height设置同一高度。
* position+margin：设置父元素:`position: relative;`，子元素`height: 100px; position:absolute;top: 50%; margin: -50px 0 0 0;`（定高）
* position+transform：设置父元素`position:relative`,子元素：`position: absolute;top: 50%;transform: translate(0, -50%);`（不定高）
* 百搭flex布局(ie10+)，设置父元素`display:flex;align-items: center;`（不定高）

### Q: `display: none`与`visibility: hidden`的区别

* 联系：它们都能让元素不可见

* 区别：

  * `display:none`会让元素完全从渲染树中消失，渲染的时候不占据任何空间；`visibility: hidden`不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见
  * `display: none`是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；`visibility: hidden`是继承属性，子孙节点消失由于继承了`hidden`，通过设置`visibility: visible`可以让子孙节点显式
  * 修改常规流中元素的`display`通常会造成文档重排。修改`visibility`属性只会造成本元素的重绘。
  * 读屏器不会读取`display: none`元素内容；会读取`visibility: hidden`元素内容

### Q: `link`与`@import`的区别

1. `link`是HTML方式， `@import`是CSS方式
2. `link`最大限度支持并行下载，`@import`过多嵌套导致串行下载，出现FOUC
3. `link`可以通过`rel="alternate stylesheet" `指定候选样式
4. 浏览器对`link`支持早于`@import`，可以使用`@import`对老浏览器隐藏样式
5. `@import`必须在样式规则之前，可以在css文件中引用其他文件
6. 总体来说：`link`优于`@import`

### Q: 什么是FOUC?如何避免

* Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。
* 解决方法：把样式表放到文档的head

### Q: 如何创建块级格式化上下文(block formatting context),BFC有什么用

* 创建规则：

  * 根元素
  * 浮动元素（float不是none）
  * 绝对定位元素（position取值为absolute或fixed）
  * display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素
  * overflow不是visible的元素
* 作用：

  * 可以包含浮动元素
  * 不被浮动元素覆盖
  * 阻止父子元素的margin折叠

### Q:css3有哪些新特性

* 新增各种css选择器
* 圆角 border-radius
* 多列布局
* 阴影和反射
* 文字特效text-shadow
* 线性渐变
* 旋转transform

#### CSS3新增伪类有那些？

* `p:first-of-type` 选择属于其父元素的首个`<p>`元素的每个`<p>` 元素。
* `p:last-of-type` 选择属于其父元素的最后 `<p>` 元素的每个`<p>` 元素。
* `p:only-of-type` 选择属于其父元素唯一的 `<p>`元素的每个 `<p>` 元素。
* `p:only-child` 选择属于其父元素的唯一子元素的每个 `<p>` 元素。
* `p:nth-child(2)` 选择属于其父元素的第二个子元素的每个 `<p>` 元素。
* `:after` 在元素之后添加内容,也可以用来做清除浮动。
* `:before` 在元素之前添加内容
* `:enabled`
* `:disabled` 控制表单控件的禁用状态。
* `:checked` 单选框或复选框被选中

### Q: display:inline-block 什么时候不会显示间隙？(携程)

* 移除空格
* 使用margin负值
* 使用font-size:0
* letter-spacing
* word-spacing

### Q：伪类与伪元素的特性及其区别

1. 伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；
2. 伪元素本质上是创建了一个有内容的虚拟容器；
3. CSS3中伪类和伪元素的语法不同（单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素）；
4. 可以同时使用多个伪类，而只能同时使用一个伪元素；

## JavaScript

### Q: 数组的方法

JavaScript的数组方法包括数组原型的方法、构造函数的方法（ES6新增部分）

针对每一个方法我们主要了解四个方面：**作用、参数、返回值、原数组是否改变**

### Q: 闭包

* 闭包就是能够读取其他函数内部变量的函数

* 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域

* 闭包的特性：

  * 函数内再嵌套函数
  * 内部函数可以引用外层的参数和变量
  * 参数和变量不会被垃圾回收机制回收
* 说说你对闭包的理解

  * 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念

  * 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中

  * 闭包的另一个用处，是封装对象的私有属性和私有方法

  * 好处：能够实现封装和缓存等；

  * 坏处：就是消耗内存、不正当使用会造成内存溢出的问题

* 使用闭包的注意点

  * 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露
  * 解决方法是，在退出函数之前，将不使用的局部变量全部删除

### Q: 说说你对作用域链的理解

* 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的
* 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期

### Q: Ajax原理

* Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据
* Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制

```js
function success(text) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');
```

* ajax 有那些优缺点?

  * 优点：
    * 通过异步模式，提升了用户体验.
    * 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.
    * Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
    * Ajax可以实现动态不刷新（局部刷新）
  * 缺点：
    * 安全问题 AJAX暴露了与服务器交互的细节。
    * 对搜索引擎的支持比较弱。
    * 不容易调试

### Q：什么情况下会碰到跨域问题？有哪些解决方法？

* 跨域问题是这是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的document、脚本，同源的意思就是两个URL的域名、协议、端口要完全相同。
* script标签jsonp跨域、nginx反向代理、node.js中间件代理跨域、后端在头部信息设置安全域名、后端在服务器上设置cors。

### Q：如何判断一个变量是对象还是数组？

判断数组和对象分别都有好几种方法，其中用`prototype.toString.call()`兼容性最好。

```js
function isObjArr(value){
     if (Object.prototype.toString.call(value) === "[object Array]") {
            console.log('value是数组');
       }else if(Object.prototype.toString.call(value)==='[object Object]'){//这个方法兼容性好一点
            console.log('value是对象');
      }else{
          console.log('value不是数组也不是对象')
      }
}
```

> ps：千万不能使用`typeof`来判断对象和数组，因为这两种类型都会返回`object`。

### Q：继承函数对象的实例方法、原型的继承。

```js
function Father(props){//父函数
  this.name=props.name||'koro1';
  this.foods = props.food || 'apple';
  this.code=function(){ //父类的实例方法(继承)
    console.log(this.name+'coding');
  }
};
Father.prototype.add=function(){ //父类的原型方法(不继承)
  console.log(this.name+'eat'+this.foods);
}
// 用F函数作为桥接实现继承
function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
function Son(props){ //子函数
  Father.call(this,props); //将this绑定到子类，绑定父类的实例方法code（原型方法add还未绑定）
  this.age=props.age|| 30;
  this.colors = props.color||'yellow';
}
Son.prototype.likeColor = function(){
  console.log(this.colors)
}

var sonVar= new Son({name:'vincent',age:44,color:'blue'});//这里也可以传参name
// 实现原型继承链:
inherits(Son, Father);
console.log(sonVar.code());
console.log(sonVar.likeColor());
```

### Q: javascript有哪些方法定义对象

* 对象字面量： `var obj = {};`
* 构造函数： `var obj = new Object();`
* `Object.create()`: `var obj = Object.create(Object.prototype);`

### Q：了解ES6的let和const变量声明吗？跟ES5的var有哪些区别？

#### let

* 在同一个作用域里面：var可以重复声明变量，let不能重复声明同一个变量。
* es5是函数作用域，即一个函数里面才是一个作用域，es6是块级作用域（花括号'{这里面是一个作用域}'），如：if、for花括号里面都是一个作用域。
* var有变量提升，可以在变量声明之前使用，let不存在变量提升，在变量之前使用会报错。
* let 有暂时性死区

#### const

* const的很多特性跟let的特性一样，都有：不可重复声明，不存在变量提升，有暂时性死区，都是块级作用域。

* 还有一些跟let命令不一样的地方：const必须在声明的时候赋值，不然就会报错。const声明的常量不能更改。

这里的常量指的是：数值、字符串、布尔值，对于引用类型（数组和对象），const只能保证指针是固定的，至于数组和对象内部有没有改变就是const不能控制的地方

### Q: 说说你对promise的了解

* Promise的意义就在于 **then 链式调用** ，它避免了异步函数之间的层层嵌套，将原来异步函数的 **嵌套关系** 转变为便于阅读和理解的 **链式步骤关系** 。

* 依照 Promise/A+ 的定义，Promise 有四种状态：

  * pending: 初始状态, 非 fulfilled 或 rejected.

  * fulfilled: 成功的操作.

  * rejected: 失败的操作.

  * settled: Promise已被fulfilled或rejected，且不是pending

* 另外， fulfilled与 rejected一起合称 settled

* Promise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算

#### Promise 的构造函数

* 构造一个 Promise，最基本的用法如下：

```js
var promise = new Promise(function(resolve, reject) {
        if (...) {  // succeed
            resolve(result);
        } else {   // fails
            reject(Error(errMessage));
        }
    });
```

* Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：

```js
promise.then(onFulfilled, onRejected)
```

* 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应resolve, onRejected对应 reject

### Q: 你觉得jQuery源码有哪些写的好的地方

* jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链
* jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法
* 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度
* jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率

### Q: vue、react、angular

* Vue.js

    一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters

* AngularJS

    是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令

* react

    React 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好。

### Q: Node的应用场景

* 特点：

    1. 它是一个Javascript运行环境
    2. 依赖于Chrome V8引擎进行代码解释
    3. 事件驱动
    4. 非阻塞I/O
    5. 单进程，单线程
* 优点：
  * 高并发（最重要的优点）
* 缺点：

    1. 只支持单核CPU，不能充分利用CPU
    2. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

### Q: 冒泡排序

* 每次比较相邻的两个数，如果后一个比前一个小，换位置

```javascript
var arr = [3, 1, 4, 6, 5, 7, 2];

function bubbleSort(arr) {
for (var i = 0; i < arr.length * 1; i++) {
    for(var j = 0; j < arr.length * 1; j++) {
        if(arr[j + 1] < arr[j]) {
            var temp;
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
return arr;
}

console.log(bubbleSort(arr));
```

### Q: 快速排序

* 采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边

```javascript
var arr = [3, 1, 4, 6, 5, 7, 2];

function quickSort(arr) {
    if(arr.length == 0) {
        return [];    // 返回空数组
    }

    var cIndex = Math.floor(arr.length / 2);
    var c = arr.splice(cIndex, 1);
    var l = [];
    var r = [];

    for (var i = 0; i < arr.length; i++) {
        if(arr[i] < c) {
            l.push(arr[i]);
        } else {
            r.push(arr[i]);
        }
    }

    return quickSort(l).concat(c, quickSort(r));
}
console.log(quickSort(arr));
```

### Q: 编写一个方法 求一个字符串的字节长度

* 假设：一个英文字符占用一个字节，一个中文字符占用两个字节

```js
function GetBytes(str){
        var len = str.length;
        var bytes = len;
        for(var i=0; i<len; i++){
            if (str.charCodeAt(i) > 255) bytes++;
        }
        return bytes;
    }
alert(GetBytes("你好,as"));

```

## 其他

### Q: 什么样的前端代码是好的

* 高复用低耦合，这样文件小，好维护，而且好扩展。

### Q: 你觉得前端工程的价值体现在哪

* 为简化用户使用提供技术支持（交互部分）

* 为多个浏览器兼容性提供支持

* 为提高用户浏览速度（浏览器性能）提供支持

* 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持

* 为展示数据提供支持（数据接口）

## 人事面

* 面试完你还有什么问题要问的吗
* 你有什么爱好?
* 你最大的优点和缺点是什么?
* 你为什么会选择这个行业，职位?
* 你觉得你适合从事这个岗位吗?
* 你有什么职业规划?
* 你对工资有什么要求?
* 如何看待前端开发？
* 未来三到五年的规划是怎样的？

## 常问

* 自我介绍
* 你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？
* 你认为哪个项目做得最好？
* 最近在看哪些前端方面的书？
* 平时是如何学习前端开发的？
* 你最有成就感的一件事
* 你是怎么学习前端的
